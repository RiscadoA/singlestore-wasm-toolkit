<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SingleStore Wasm Toolkit</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Tutorial-Developing-Wasm-UDF-CPP.html"><strong aria-hidden="true">1.</strong> Tutorial: Developing Wasm UDFs in C/C++</a></li><li class="chapter-item expanded "><a href="../Tutorial-Developing-Wasm-UDF-Rust.html"><strong aria-hidden="true">2.</strong> Tutorial: Developing Wasm UDFs in Rust</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SingleStore Wasm Toolkit</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="singlestore-wasm-udf-tutorial"><a class="header" href="#singlestore-wasm-udf-tutorial">SingleStore Wasm UDF Tutorial</a></h1>
<!-- The original tutorial -->
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This tutorial will teach you how to write some simple WebAssembly (Wasm) UDFs in in C/C++, load them into the database, and evaluate them in queries.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>For each example in this tutorial, it will be useful to create yourself a separate work directory in which to put your code and compiled artifacts. This will help keep your files for each example organized.</p>
<p>In addition to a SQL client and SingleStore database, you’ll need a few other things to get your environment set up properly. For this, you have a couple of options.</p>
<h3 id="vs-code-devcontainer-setup"><a class="header" href="#vs-code-devcontainer-setup">VS Code DevContainer Setup</a></h3>
<p>The easiest way to get started is to download the <a href="https://github.com/singlestore-labs/singlestore-wasm-toolkit">SingleStore WASM Toolkit</a> repository.
This repo provides a VS Code DevContainer with all of the tools you'll need to work with WASM UDFs and complete this tutorial. It also includes fully-written versions of the tutorial code.</p>
<p>You can install VS Code <a href="https://code.visualstudio.com/download">here</a> then follow these steps:</p>
<ol>
<li>
<p>Run git clone git@github.com:singlestore-labs/singlestore-wasm-toolkit.git</p>
</li>
<li>
<p>Install the Remote - Containers VS Code Extension if you do not already have it.</p>
</li>
<li>
<p>In VS Code, type F1 and search for “Open Folder in Container”.</p>
</li>
<li>
<p>Navigate to the directory where you cloned the project in step 1, and click Open. The container will build, which may take a few minutes.</p>
</li>
</ol>
<p>When the container build completes, you are ready to go. Execute your commands inside the VS Code terminal window so that the required command-line tools are available.</p>
<blockquote>
<p><strong>Note</strong>
Make sure to run your SQL client on your local system, outside of the container.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>
Create your folders inside the repository structure so they are available within the container.</p>
</blockquote>
<!-- These use a special GitHub-flavored .md feature -->
<h3 id="manual-setup"><a class="header" href="#manual-setup">Manual Setup</a></h3>
<p>If you’d prefer to set up your development environment manually, you’ll need to do the following:</p>
<ul>
<li>
<p>Download the <a href="https://github.com/WebAssembly/wasi-sdk/releases">WASI SDK</a> and decompress it somewhere. For the purposes of this tutorial, it might be convenient to create a shell alias to the version of clang in this tarball. For example, if you uncompressed the tarball under /opt, then you can run the following:</p>
<ul>
<li>
<p><code>alias clang=/opt/wasi-sdk-14.0/bin/clang</code></p>
</li>
<li>
<p><code>alias clang++=/opt/wasi-sdk-14.0/bin/clang++</code></p>
</li>
</ul>
</li>
<li>
<p>Download and install the Rust toolchain:</p>
<ul>
<li>
<p><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></p>
</li>
<li>
<p><code>source $HOME/.cargo/env</code> (or restart your shell)</p>
</li>
</ul>
</li>
<li>
<p>Download and install the wit-bindgen program:</p>
<ul>
<li><code>cargo install --git https://github.com/bytecodealliance/wit-bindgen wit-bindgen-cli</code></li>
</ul>
</li>
</ul>
<h2 id="developing-a-simple-example"><a class="header" href="#developing-a-simple-example">Developing a Simple Example</a></h2>
<h3 id="creating-the-wit-specification"><a class="header" href="#creating-the-wit-specification">Creating the WIT Specification</a></h3>
<p>Before we do any coding, let’s first define our interface. WIT is an Interface Definition Language (IDL) used for describing WASM modules in <code>*.wit</code> files. We'll create a .wit specification for our new function. In a new work directory, open a new file called power.wit in your text editor.</p>
<p>Let’s say we want to develop a program that simply computes x^y (that is, x to the power of y). The interface for this is simple; here is the WIT IDL for it:</p>
<pre><code class="language-wit">power-of: function(base: s32, exp: s32) -&gt; s32
</code></pre>
<p>This function will take two signed 32-bit integers as arguments (the base and the exponent) and return a single signed 32-bit integer.</p>
<p>Copy and paste the above code into power.wit and save it. Now we’re ready to write some code.</p>
<h3 id="using-bindgen"><a class="header" href="#using-bindgen">Using Bindgen</a></h3>
<p>We’ll start by generating the C language bindings for our functions. We can do this using the wit-bindgen program (demo). In your work directory, run the following command:</p>
<pre><code class="language-bash">wit-bindgen c --export power.wit
</code></pre>
<p>This will generate two files in your work directory:  <code>power.c</code> and <code>power.h</code>.</p>
<p>If you look at the contents of the <code>power.h</code> file, you’ll see a single prototype:</p>
<pre><code class="language-cpp">int32_t power_power_of(int32_t base, int32_t exp);
</code></pre>
<p>The name looks odd because wit-bindgen concatenates the name of the WIT file with the name of the function. That’s ok; as we’ll see in a moment, the name that is actually exported will make more sense.</p>
<p>Aside from the function name, the signature is as expected:  take two 32-bit integers, and return one.</p>
<p>Next, open the <code>power.c</code> file in your editor. We’ll ignore the <code>canonical_abi_realloc</code> and <code>canonical_abi_free</code> functions for now and skip to the bottom where we will find a function called <code>__wasm_export_power_power_of</code>. This is wrapper code that handles passing values through the Wasm Canonical ABI (a trivial operation in this case). Looking at the body of this function, we can see that it calls the <code>power_power</code> function that was declared in the header file. We’ll need to provide the implementation for this.</p>
<p>Before we continue, though, notice the following line just above the this function’s definition:</p>
<pre><code class="language-cpp">__attribute__((export_name(&quot;power-of&quot;)))
</code></pre>
<p>This line forces the name of this wrapper function be exported from the compiled module as power-of (the hyphen is the preferred word separator for function names in Wasm). Fortunately, consumers only need to invoke it by this name.</p>
<h3 id="implementing-and-running"><a class="header" href="#implementing-and-running">Implementing and Running</a></h3>
<p>Now, let’s implement the logic we need. To the bottom of the <code>power.c</code> file, add the following code (we can start by copying in the prototype from the <code>power.h</code> file):</p>
<pre><code class="language-cpp">int32_t power_power_of(int32_t base, int32_t exp)
{
    int32_t res = 1;
    for (int32_t i = 0; i &lt; exp; ++i)
    {
        res *= base;
    }
    return res;
}
</code></pre>
<p>Now let’s save the file and get back to our command line.</p>
<p>We can compile this program into a Wasm module by using the following command.</p>
<pre><code class="language-bash">clang                            \
    --target=wasm32-unknown-wasi \
    -mexec-model=reactor         \
    -s                           \
    -I.                          \
    -o power.wasm                \
    power.c
</code></pre>
<p>You should now see a <code>power.wasm</code> file in your directory.</p>
<p>All that’s left to do is load it into the database. Fire up your favorite SingleStore instance and connect a SQL client to it. You’ll need to make sure the “local infile” feature is enabled; to do this in the mysql CLI, pass the <code>--local-infile=ON</code> argument.</p>
<p>In your SQL client, issue the following commands. For this tutorial, we’ll just create a scratch database called <code>wasm_tutorial</code>.
You may need to adjust the paths to your files if your SQL client is not in the same directory as them or does not support relative paths.</p>
<pre><code class="language-sql">CREATE DATABASE wasm_tutorial;
USE wasm_tutorial;
CREATE FUNCTION `power-of` AS WASM FROM INFILE 'power.wasm' WITH WIT FROM INFILE 'power.wit';
</code></pre>
<p>If the UDF has been created successfully, you will see something like:</p>
<pre><code>Query OK, 1 row affected (0.029 sec)
</code></pre>
<p>Now our UDF is ready to run!  To do this, just run the following command:</p>
<pre><code class="language-sql">SELECT `power-of`(2, 8);
</code></pre>
<p>... which should return a single-column row with the value 256, of course.</p>
<p>Before moving on to the next example, drop your <code>wasm_tutorial</code> database.</p>
<pre><code class="language-sql">DROP DATABASE wasm_tutorial
</code></pre>
<h2 id="a-more-complex-example"><a class="header" href="#a-more-complex-example">A More Complex Example</a></h2>
<h3 id="creating-the-wit-specification-1"><a class="header" href="#creating-the-wit-specification-1">Creating the WIT Specification</a></h3>
<p>In this example, we’ll work with strings and nested types. Let’s create a function that takes a string, splits it at every occurrence of a delimiting string, and then returns each sub-string along with its starting indices. The output will be sent back as a list of records (aka structures).</p>
<p>To start, let’s create a new work directory, and inside of it we’ll make a new file called <code>split.wit</code>. The WIT IDL we need is below, so we can go ahead and paste that in and save it.</p>
<pre><code class="language-wit">record subphrase {
  str: string,
  idx: s32
}
split-str: function(phrase: string, delim: string) -&gt; list&lt;subphrase&gt;
</code></pre>
<h3 id="implementing-the-specification"><a class="header" href="#implementing-the-specification">Implementing the Specification</a></h3>
<p>With this example, we’ll use C++ so that we can leverage the STL’s higher-level data structures and keep our implementation focused on the big picture as much as possible.</p>
<p>As before, we’ll start by generating the C language bindings. Run the <em>wit-bindgen</em> command:</p>
<pre><code class="language-bash">wit-bindgen c --export split.wit
</code></pre>
<p>There should now be a <code>split.c</code> and <code>split.h</code> file in your work directory. Since we’ll be using C++, rename <code>split.c</code> to <code>split.cpp</code>:</p>
<pre><code class="language-bash">mv split.c split.cpp
</code></pre>
<p>Now let’s take a look at <code>split.h</code>. As we might expect, there are a few more definitions in here than before. The wit-bindgen program has generated a struct definition for us to use when passing our strings, as well as ones for the subphrase record and its enclosing list. At the bottom is prototype for the function we are going to implement:</p>
<pre><code class="language-cpp">void split_split_str(split_string_t *phrase, split_string_t *delim, split_list_subphrase_t *ret0);
</code></pre>
<p>This, too, looks a bit different than before. For one thing, the function doesn’t return a value. Since this function will be returning a list, for which we’ll need to dynamically allocate memory, the result is passed as an argument pointer instead.</p>
<p>Now let’s open up the <code>split.cpp</code> file. Once again, we are going to add our implementation here. At the bottom of the file, we can find the generated wrapper function, called <code>__wasm_export_split_split_str</code>. This wrapper delegates to our function, and we also can see that it  is doing work required for lifting and lowering the data types on either side of the function call.</p>
<p>We’ll now add our code. Let’s first update the top of <code>split.cpp</code> as follows:</p>
<pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;split.h&gt;
</code></pre>
<p>Since C++ has a more strict compiler than C, we’ll also need to make a small change to the generated code in this file at line 38. Go ahead and change the following line:</p>
<pre><code class="language-cpp">ret-&gt;ptr = canonical_abi_realloc(NULL, 0, 1, ret-&gt;len);
</code></pre>
<p>... to this:</p>
<pre><code>ret-&gt;ptr = reinterpret_cast&lt;char *&gt;(canonical_abi_realloc(NULL, 0, 1, ret-&gt;len));
</code></pre>
<p>And finally, to the bottom of the file, we’ll add this chunk of code:</p>
<pre><code class="language-cpp">void split_split_str(split_string_t *phrase, split_string_t *delim, split_list_subphrase_t *ret0)
{
    // Clear the result.
    memset(ret0, 0, sizeof(split_list_subphrase_t));

    // Parse the tokens.
    std::string phr(phrase-&gt;ptr, phrase-&gt;len);
    std::string dlm(delim-&gt;ptr, delim-&gt;len);
    std::string tok;
    std::vector&lt;std::pair&lt;std::string, size_t&gt;&gt; subs;
    size_t start = 0, end = 0;
    if (delim-&gt;len)
    {
        while ((end = phr.find(dlm, start)) != std::string::npos)
        {
            tok = phr.substr(start, end - start);
            subs.push_back(std::pair&lt;std::string, size_t&gt;(tok, start));
            start = end + dlm.length();
        }
    }
    subs.push_back(std::pair&lt;std::string, size_t&gt;(phr.substr(start), start));

    // Populate the result.
    bool err = false;
    auto res = (split_subphrase_t *) malloc(phr.size() * sizeof(split_subphrase_t));
    for (int i = 0; !err &amp;&amp; i &lt; subs.size(); ++i)
    {
        auto&amp; sub = subs[i].first;
        res[i].idx = static_cast&lt;int32_t&gt;(subs[i].second);
        res[i].str.len = sub.length();
        res[i].str.ptr = strdup(sub.c_str());
        if (!res[i].str.ptr)
            err = true;
    }

    // If success, assign the result. Else, clean up and return an empty list.
    if (!err)
    {
        // Success; assign the result.
        ret0-&gt;ptr = res;
        ret0-&gt;len = subs.size();
    }
    else
    {
        if (res)
        {
            for (int i = 0; i &lt; subs.size(); ++i)
                if (res[i].str.ptr)
                    free(res[i].str.ptr);
            free(res);
        }
    }

    // Per the Canonical ABI contract, free the input pointers.
    free(phrase-&gt;ptr);
    free(delim-&gt;ptr);
}
</code></pre>
<p>Obviously, there is much more work going on here than in our first example; a fair amount of it deals with memory management.</p>
<p>The Wasm Canonical ABI requires that any dynamic memory passed from the host to the guest or vice-versa transfers the ownership to the receiver. This explains the last two lines of our <code>split_split_str</code> function, where we free the pointers to the strings we have been passed as arguments. This memory will have been allocated by the host using our guest module’s exported <code>canonical_abi_realloc</code> function, which takes it from the Wasm instance’s linear memory at runtime. Conversely, you may also notice that we pass dynamically allocated memory out of the function; the host is expected to free it by calling our module's <code>canonical_abi_free</code> routine, which will return it to the linear memory.</p>
<p>Now let’s save the file and build the module. We will use a similar approach as we did in the simple example above, but with a couple of tweaks. First, we’ll use clang++, since this is C++ code. And second, we’ll need to include the option <code>-fno-exceptions</code> because Wasm doesn’t yet support exception handling (there is a proposal, however).</p>
<pre><code class="language-bash">clang++                          \
    -fno-exceptions              \
    --target=wasm32-unknown-wasi \
    -mexec-model=reactor         \
    -s                           \
    -I.                          \
    -o split.wasm                \
    split.cpp
</code></pre>
<p>As expected, there should now be a <code>split.wasm</code> file in your work directory.</p>
<h3 id="running-the-new-udf"><a class="header" href="#running-the-new-udf">Running the New UDF</a></h3>
<p>Hooray!  It’s time to load it into the database and try it out. Another difference between the simple example and this one is that, while we previously returned a scalar value from our UDF, we are now returning a list of records. This aspect makes the function suitable for use as a TVF. And, we only need to make a small change to the SQL syntax to do it (by adding the <code>RETURNS TABLE</code> clause).</p>
<p>Start your database client up, again making sure you enable the “local infile” feature (<code>--local-infile=ON</code> for mysql), and issue the following statements. 
You may need to adjust the paths to your files if your SQL client is not in the same directory as them or does not support relative paths.</p>
<pre><code class="language-sql">CREATE DATABASE wasm_tutorial;
USE wasm_tutorial;
CREATE FUNCTION `split-str` RETURNS TABLE AS WASM FROM INFILE 'split.wasm' WITH WIT FROM INFILE 'split.wit';
</code></pre>
<p>Now we can run our Wasm function as a TVF like this:</p>
<pre><code class="language-sql">SELECT * FROM `split-str`('wasm_rocks_the_house', '_');
</code></pre>
<p>... which will produce the following output:</p>
<pre><code>+-------+-----+
| str   | idx |
+-------+-----+
| wasm  |   0 |
| rocks |   5 |
| the   |  11 |
| house |  15 |
+-------+-----+
94 rows in set (0.001 sec)
</code></pre>
<p>Awesome!</p>
<h2 id="wrap-up"><a class="header" href="#wrap-up">Wrap-Up</a></h2>
<p>Well, this concludes our little tutorial. Using both the C/C++ we were able to turn simple and not-quite-so-simple use cases into WebAssembly programs. We also learned how to load them into the SingleStore database in form of UDFs and TVFs, and then run them.</p>
<p>Hopefully, this helps you kickstart your own Wasm UDFs. Thanks for tuning in!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="singlestore-wasm-udf-tutorial-1"><a class="header" href="#singlestore-wasm-udf-tutorial-1">SingleStore Wasm UDF Tutorial</a></h1>
<!-- The original tutorial -->
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>This tutorial will teach you how to write some simple WebAssembly (Wasm) UDFs in in Rust, load them into the database, and evaluate them in queries.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>For each example in this tutorial, it will be useful to create yourself a separate work directory in which to put your code and compiled artifacts. This will help keep your files for each example organized.</p>
<p>In addition to a SQL client and SingleStore database, you’ll need a few other things to get your environment set up properly. For this, you have a couple of options.</p>
<h3 id="vs-code-devcontainer-setup-1"><a class="header" href="#vs-code-devcontainer-setup-1">VS Code DevContainer Setup</a></h3>
<p>The easiest way to get started is to download the <a href="https://github.com/singlestore-labs/singlestore-wasm-toolkit">SingleStore WASM Toolkit</a> repository.
This repo provides a VS Code DevContainer with all of the tools you'll need to work with WASM UDFs and complete this tutorial. It also includes fully-written versions of the tutorial code.</p>
<p>You can install VS Code <a href="https://code.visualstudio.com/download">here</a> then follow these steps:</p>
<ol>
<li>
<p>Run git clone git@github.com:singlestore-labs/singlestore-wasm-toolkit.git</p>
</li>
<li>
<p>Install the Remote - Containers VS Code Extension if you do not already have it.</p>
</li>
<li>
<p>In VS Code, type F1 and search for “Open Folder in Container”.</p>
</li>
<li>
<p>Navigate to the directory where you cloned the project in step 1, and click Open. The container will build, which may take a few minutes.</p>
</li>
</ol>
<p>When the container build completes, you are ready to go. Execute your commands inside the VS Code terminal window so that the required command-line tools are available.</p>
<blockquote>
<p><strong>Note</strong>
Make sure to run your SQL client on your local system, outside of the container.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>
Create your folders inside the repository structure so they are available within the container.</p>
</blockquote>
<!-- These use a special GitHub-flavored .md feature -->
<h3 id="manual-setup-1"><a class="header" href="#manual-setup-1">Manual Setup</a></h3>
<p>If you’d prefer to set up your development environment manually, you’ll need to do the following:</p>
<ul>
<li>
<p>Download and install the Rust toolchain and WASM targets:</p>
<ul>
<li>
<p><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></p>
</li>
<li>
<p><code>source $HOME/.cargo/env</code> (or restart your shell)</p>
</li>
<li>
<p><code>rustup target add wasm32-wasi</code></p>
</li>
</ul>
</li>
<li>
<p>Download and install the wit-bindgen program:</p>
<ul>
<li><code>cargo install --git https://github.com/bytecodealliance/wit-bindgen wit-bindgen-cli</code></li>
</ul>
</li>
</ul>
<h2 id="developing-a-simple-example-1"><a class="header" href="#developing-a-simple-example-1">Developing a Simple Example</a></h2>
<h3 id="creating-the-wit-specification-2"><a class="header" href="#creating-the-wit-specification-2">Creating the WIT Specification</a></h3>
<p>Before we do any coding, let’s first define our interface. WIT is an Interface Definition Language (IDL) used for describing WASM modules in <code>*.wit</code> files. We'll create a .wit specification for our new function. In a new work directory, open a new file called power.wit in your text editor.</p>
<p>Let’s say we want to develop a program that simply computes $x^y$. The interface for this is simple; here is the WIT IDL for it:</p>
<pre><code class="language-wit">power-of: function(base: s32, exp: s32) -&gt; s32
</code></pre>
<p>This function will take two signed 32-bit integers as arguments (the base and the exponent) and return a single signed 32-bit integer.</p>
<p>Copy and paste the above code into power.wit and save it. Now we’re ready to write some code.</p>
<h3 id="using-bindgen-1"><a class="header" href="#using-bindgen-1">Using Bindgen</a></h3>
<p>To implement this interface in Rust, we're going to use wit-bindgen. First, from within a new work directory, run <code>cargo init --vcs none --lib</code>. This will set up a skeletal Rust source tree.</p>
<p>Next, edit the file called <code>Cargo.toml</code> so that it looks like the following:</p>
<pre><code class="language-toml">[package]
name = &quot;power&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
wit-bindgen-rust = { git = &quot;https://github.com/bytecodealliance/wit-bindgen.git&quot; }

[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>We’ll also need the power.wit file we used above. Either recreate it or copy it into your work directory.</p>
<p>Now we’re almost ready to roll. Edit the file <code>src/lib.rs</code> and replace its content with this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wit_bindgen_rust::export!(&quot;power.wit&quot;);
struct Power;

impl power::Power for Power {
    fn power_of(base: i32, exp: i32) -&gt; i32 {
        let mut res = 1;
        for _i in 0..exp {
            res *= base;
        }
        res
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The syntax at the top of the code is boiler-plate. The export macro generates code that declares a trait named after our WIT file (and some other things). So, our main job is here is to implement this trait. If you are curious what the macro actually generates, you can run cargo expand and it will show you the fully expanded source code.</p>
<p>The WIT IDL is heavily inspired by the Rust language syntax, so it was pretty easy to derive the Rust function signature we needed from the IDL:</p>
<ul>
<li>
<p>Replaced hyphens with underscores</p>
</li>
<li>
<p>Changed s32 types to i32</p>
</li>
</ul>
<p>Now we can compile the program into a wasm module using this command:</p>
<pre><code class="language-bash">cargo wasi build --lib
</code></pre>
<p>We can now load the module into the database using the same procedure we discussed above. The Wasm module is written to <code>target/wasm32-wasi/debug/power.wasm</code>, so we need to make sure the Wasm <em>infile</em> path is pointing there instead of the work tree’s root.</p>
<pre><code class="language-sql">CREATE DATABASE wasm_tutorial;
USE wasm_tutorial;
CREATE FUNCTION `power-of` AS WASM FROM INFILE '/workdir/target/wasm32-wasi/debug/power.wasm' WITH WIT FROM INFILE '/workdir/power.wit';
</code></pre>
<p>And, once again, running the following SQL gives us back the expected result of 256.</p>
<pre><code class="language-sql">SELECT `power-of`(2, 8);
</code></pre>
<p>Before moving on to the next example, drop your <code>wasm_tutorial</code> database.</p>
<pre><code class="language-sql">DROP DATABASE wasm_tutorial
</code></pre>
<h2 id="a-more-complex-example-1"><a class="header" href="#a-more-complex-example-1">A More Complex Example</a></h2>
<h3 id="creating-the-wit-specification-3"><a class="header" href="#creating-the-wit-specification-3">Creating the WIT Specification</a></h3>
<p>In this example, we’ll work with strings and nested types. Let’s create a function that takes a string, splits it at every occurrence of a delimiting string, and then returns each sub-string along with its starting indices. The output will be sent back as a list of records (aka structures).</p>
<p>To start, let’s create a new work directory, and inside of it we’ll make a new file called <code>split.wit</code>. The WIT IDL we need is below, so we can go ahead and paste that in and save it.</p>
<pre><code class="language-wit">record subphrase {
  str: string,
  idx: s32
}
split-str: function(phrase: string, delim: string) -&gt; list&lt;subphrase&gt;
</code></pre>
<h3 id="implementing"><a class="header" href="#implementing">Implementing</a></h3>
<p>For our last trick, we’ll split strings in Wasm using a Rust-based implementation.
Much of this will be similar to the techniques we used in the simple example.</p>
<p>Start by creating a new work directory and initializing it using <code>cargo init --vcs none --lib</code>.</p>
<p>Now, edit the <code>Cargo.toml</code> file so it looks like this:</p>
<pre><code class="language-toml">[package]
name = &quot;split&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
wit-bindgen-rust = { git = &quot;https://github.com/bytecodealliance/wit-bindgen.git&quot; }

[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>Next, let’s copy or recreate the split.wit file in our work directory.</p>
<p>And, for the implementation, edit the <code>src/lib.rs</code> file and replace its contents with this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wit_bindgen_rust::export!(&quot;split.wit&quot;);
struct Split;
use crate::split::Subphrase;

impl split::Split for Split {

    fn split_str(phrase: String, delim: String) -&gt; Vec&lt;Subphrase&gt; {
        phrase
            .split(&amp;delim)
            .scan(0, |idx, s| {
                let current = Subphrase {
                    str: s.to_string(),
                    idx: *idx as i32
                };
                *idx += (s.len() + delim.len()) as i32;
                Some(current)
            })
            .collect()
    }
} 
<span class="boring">}
</span></code></pre></pre>
<p>Fortunately, with Rust, we have some nice language features that help make our code concise. Notice how, unlike in C++, we don’t need to explicitly free the parameters. Due to Rust’s move semantics, they will be freed implicitly when the function ends. Allocation for the output vector is also managed “under the hood” by Rust’s robust data structures and runtime. Finally, the declaration of the Subphrase struct happens via the <code>wit_bindgen_rust::export macro</code>, so we don’t need to do it.</p>
<p>Let’s compile the Wasm module now:</p>
<pre><code class="language-bash">cargo wasi build --lib
</code></pre>
<p>And, we’ll finish up by loading the module into the database as TVF, just as we did with the simple example. Note again that our Wasm module is down in the target/debug directory.</p>
<pre><code class="language-sql">CREATE DATABASE wasm_tutorial;
USE wasm_tutorial;
CREATE FUNCTION `split-str` RETURNS TABLE AS WASM FROM INFILE '/workdir/target/wasm32-wasi/debug/split.wasm' WITH WIT FROM INFILE '/workdir/split.wit';
</code></pre>
<p>Then:</p>
<pre><code class="language-sql">SELECT * FROM `split-str`('wasm_rocks_the_house', '_');
</code></pre>
<h2 id="wrap-up-1"><a class="header" href="#wrap-up-1">Wrap-Up</a></h2>
<p>Well, this concludes our little tutorial. Using both the C/C++ and Rust programming languages we were able to turn simple and not-quite-so-simple use cases into WebAssembly programs. We also learned how to load them into the SingleStore database in form of UDFs and TVFs, and then run them.</p>
<p>Hopefully, this helps you kickstart your own Wasm UDFs. Thanks for tuning in!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
